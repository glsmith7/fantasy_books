# initializing dictionary
from bisect import bisect_left

def take_closest(myList, myNumber):
        """
        Assumes myList is sorted. Returns closest value to myNumber.

        If two numbers are equally close, return the smallest number.
        From: https://stackoverflow.com/questions/12141150/from-list-of-integers-get-number-closest-to-a-given-value
        """
        pos = bisect_left(myList, myNumber)
        if pos == 0:
            return myList[0]
        if pos == len(myList):
            return myList[-1]
        before = myList[pos - 1]
        after = myList[pos]
        if after - myNumber < myNumber - before:
            return after
        else:
            return before   

probability_array = {0: 5, 1: 36, 2: 36, 3: 38, 4: 38, 5: 84, 6: 208, 7: 241, 8: 246, 9: 247, 10: 247, 11: 266, 12: 284, 13: 306, 14: 339, 15: 435, 16: 534, 17: 534, 18: 534, 19: 1984, 20: 2594, 21: 2596, 22: 2610, 23: 2612, 24: 2626, 25: 2631, 26: 2647, 27: 2647, 28: 2684, 29: 3252, 30: 3710, 31: 3931, 32: 3931, 33: 3944, 34: 4670, 35: 4829, 36: 6434, 37: 6491, 38: 6577, 39: 6588, 40: 6678, 41: 6680, 42: 6694, 43: 6703, 44: 6705, 45: 6737, 46: 6737, 47: 6743, 48: 6766, 49: 7023, 50: 7057, 51: 7058, 52: 7059, 53: 7083, 54: 7083, 55: 7157, 56: 7186, 57: 7187, 58: 7202, 59: 7202, 60: 7205, 61: 7211, 62: 7211, 63: 7686, 64: 7694, 65: 7717, 66: 7758, 67: 7804, 68: 7821, 69: 8851, 70: 8854, 71: 8944, 72: 8945, 73: 8945, 74: 8958, 75: 9095, 76: 9669, 77: 9692, 78: 9780, 79: 9791, 80: 9829, 81: 9899, 82: 10214, 83: 10229, 84: 10230, 85: 10238, 86: 10239, 87: 11552, 88: 11553, 89: 12488, 90: 12540, 91: 12544, 92: 12575, 93: 12688, 94: 12969, 95: 13011, 96: 14056, 97: 14056, 98: 14305, 99: 14308, 100: 14310, 101: 14323, 102: 14353, 103: 14356, 104: 14380, 105: 14381, 106: 14837, 107: 14840, 108: 14953, 109: 14982, 110: 15088, 111: 15116, 112: 15132, 113: 15132, 114: 15444, 115: 15456, 116: 15459, 117: 15871, 118: 16065, 119: 16065, 120: 16889, 121: 17138, 122: 17283, 123: 17546, 124: 17600, 125: 17600, 126: 17644, 127: 17647, 128: 17648, 129: 17813, 130: 17830, 131: 17830, 132: 17831, 133: 17853, 134: 17874, 135: 17880, 136: 18071, 137: 18074, 138: 18095, 139: 18099, 140: 18165, 141: 18183, 142: 18208, 143: 18251, 144: 18266, 145: 18395, 146: 18646, 147: 19621, 148: 19621, 149: 19638, 150: 19642, 151: 19646, 152: 19877, 153: 19966, 154: 19966, 155: 20180, 156: 20181, 157: 20185, 158: 20191, 159: 20237, 160: 20244, 161: 21196, 162: 21220, 163: 21243, 164: 21252, 165: 21254, 166: 21279, 167: 21388, 168: 21408, 169: 21411, 170: 21432, 171: 21461, 172: 21474, 173: 21560, 174: 21621, 175: 21867, 176: 21925, 177: 22090, 178: 23050, 179: 23061, 180: 23104, 181: 25075, 182: 26673, 183: 26678, 184: 27983, 185: 27983, 186: 28035, 187: 28035}

the_roll = 16066

running_total_list = list (probability_array.values())
the_closest = take_closest(running_total_list,the_roll)
the_index = running_total_list.index(the_closest)
# the_index -= 1

while True:
    gls = probability_array[the_index+1]
    if the_roll > probability_array[the_index]:
         the_index+=1
    else:
         break
    

print ("Number found:" + str(the_closest))
print ("The Index:" + str(the_index))
print ("Value:" + str (probability_array[the_index]))
